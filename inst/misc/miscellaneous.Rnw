% \VignetteIndexEntry{Miscellaneous}
% \VignetteEngine{knitr::knitr}
% \VignetteDepends{wrv}

\documentclass[twoside]{article}

\input{\Sexpr{shQuote(system.file("misc", "preamble.tex", package="inlmisc"))}}

\renewcommand{\thefigure}{X\arabic{figure}}
\renewcommand{\thetable}{X\arabic{table}}
\renewcommand{\thepage}{X\arabic{page}}

% =========================================================================

\begin{document}

<<setup, include=FALSE>>=
t0 <- Sys.time()
try(knitr::opts_chunk$set(tidy=FALSE, comment="#", fig.align="center"), silent=TRUE)
grDevices::pdf.options(useDingbats=FALSE)
options(preferRaster=TRUE, scipen=0, digits=2)
library(wrv)
loadNamespace("viridisLite")
loadNamespace("xtable")

# Device dimension in inches (width, height)
fin.graph         <- c(7.17, 7.17)
fin.graph.short   <- c(7.17, 3.50)
fig.graph.small   <- c(3.50, 3.50)
fin.map           <- c(7.17, 9.31)
fin.map.0         <- c(7.17, 8.77)
fin.map.s         <- c(7.17, 5.22)
fin.map.s.0       <- c(7.17, 4.68)
fin.map.n         <- c(7.17, 6.97)
fin.map.n.small   <- c(3.50, 3.60)
fin.map.n.small.0 <- c(3.50, 3.30)
fin.cs            <- c(7.17, 5.26)
fin.cs.0          <- c(7.17, 4.68)

# Extreme coordinates of plotting region (x1, x2, y1, y2)
usr.map     <- c(2451504, 2497815, 1342484, 1402354)
usr.map.s   <- c(2472304, 2497015, 1343284, 1358838)
usr.map.n.1 <- c(2463000, 2475356, 1386500, 1398856)
usr.map.n.2 <- c(2467500, 2479856, 1376500, 1388856)
usr.map.n.3 <- c(2466696, 2479052, 1366501, 1378857)
usr.map.n.4 <- c(2471500, 2483856, 1356482, 1368838)

# Verticies of transect line from north-west to south-east (longitude, latitude)
transect.coords <- rbind(c(-114.280851, 43.483026),
                         c(-114.245614, 43.432551),
                         c(-114.228996, 43.350930),
                         c(-114.045926, 43.301372))

# Unit conversions
m3.per.d.to.af.per.yr <- 0.296106669
m2.to.ac              <- 0.000247105

# Map credit
credit <- paste("Base derived from U.S. Geological Survey National Elevation Dataset 10-meter digital elevation model.",
                "Idaho Transverse Mercator projection; North American Datum of 1983.", sep="\n")
@

\title{Miscellaneous}
\author{}
\maketitle

\tableofcontents

\renewcommand*\listfigurename{Figures}
\listoffigures

\renewcommand*\listtablename{Tables}
\listoftables

\clearpage

\RaggedRight

% =========================================================================

\section{Introduction}

Set the path to the calibrated model run directory:

<<set_path>>=
path <- "C:/Users/jfisher/Desktop/Model Run"
@

All output from this vignette is placed in the current working directory.
The following command will print the path to the current working directory:

<<>>=
getwd()
@

<<echo=FALSE>>=
load(file.path(path, "model.rda"))

transect <- SpatialLines(list(Lines(list(Line(transect.coords)), ID="Transect")),
                         proj4string=CRS("+init=epsg:4326"))
transect <- spTransform(transect, crs(rs))
verticies <- as(transect, "SpatialPoints")
transect.ends <- verticies[c(1, length(verticies)), ]

budget <- ReadModflowBinary(file.path(path, "wrv_mfusg.bud"), "flow")
b <- SummariseBudget(budget, c("wells", "drains", "river leakage"), id="id")
b <- dplyr::mutate(b, totim.date=as.Date(totim, origin="1995-01-01"))


ReadRef <- function(f, mask.value=1e+09) {
  x <- scan(file.path(path, f), quiet=TRUE)
  x[x == mask.value] <- NA
  r <- raster(rs)
  r[] <- x
  return(r)
}

TidyBudget <- function(b, desc, id=NA) {
  d <- b[b$desc == desc & b$id == id, c("flow.dir", "flow.sum", "totim.date")]
  d <- dplyr::summarise(dplyr::group_by(d, totim.date, flow.dir), flow=sum(flow.sum))
  d <- merge(d[d$flow.dir == "in",  c("totim.date", "flow")],
             d[d$flow.dir == "out", c("totim.date", "flow")],
             by="totim.date", all=TRUE, suffixes=c(".in", ".out"))
  d <- cbind(d, flow.total=rowSums(d[, c("flow.in", "flow.out")]))
  return(d)
}
@

% =========================================================================

\section{Study Area}

Something... (\hyperref[fig:map_study_area]{fig.~\ref{fig:map_study_area}}).

<<map_study_area, echo=FALSE, fig.width=fin.map.0[1], fig.height=fin.map.0[2], fig.cap="{Location and general features of the Wood River Valley, south-central Idaho.}">>=
r <- rasterize(alluvium.extent, raster(hill.shading))
PlotMap(r, xlim=usr.map[1:2], ylim=usr.map[3:4], bg.image=hill.shading,
        col="#C0C0C0", bg.image.alpha=0.4, dms.tick=TRUE,
        rivers=list(x=streams.rivers), lakes=list(x=lakes),
        roads=list(x=major.roads), credit=credit, draw.key=FALSE,
        scale.loc="bottomleft")
plot(alluvium.extent, border="#F0D87880", add=TRUE)
points(streamgages, pch=24, cex=1, col="#FFFFFFB1", bg="#88263B")
pos <- c(3, 4, 3, 4, 3, 2, 3, 2, 3)
text(streamgages, labels=streamgages@data$SiteNo,
     col="#88263B", cex=0.5, pos=pos, offset=0.4)
plot(cities, pch=15, cex=0.8, col="#333333", add=TRUE)
text(cities, labels=cities@data$FEATURE_NA, col="#333333", cex=0.5, pos=1, offset=0.4)
lab <- cbind(map.labels@coords, map.labels@data)
for (i in seq_len(nrow(lab))) {
  text(lab$x[i], lab$y[i], labels=lab$label[i], cex=lab$cex[i], col=lab$col[i],
       font=lab$font[i], srt=lab$srt[i])
}
plot(bypass.canal, col="#3399CC", lwd=0.5, add=TRUE)
text(getSpatialLinesMidPoints(rgeos::gLineMerge(bypass.canal)), labels="Bypass Canal",
     cex=0.5, col="#3399CC", font=3, srt=80, pos=1)
AddInsetMap(idaho, width=1, main.label=list("IDAHO", adj=c(-0.4, -4.9)),
            sub.label=list("Map area", adj=c(0.5, 2.5)), loc="topright")
usr <- par("usr")
x <- usr[1] + (usr[2] - usr[1]) * 0.02
y <- usr[3] + (usr[4] - usr[3]) * 0.25
leg <- c("Wood River Valley aquifer system extent", "Streamgages")
col <- c("#F0D87880", "#FFFFFFB1")
bg  <- c("#C0C0C0FF", "#88263BFF")
legend(x, y, leg, pch=c(22, 24), col=col, pt.bg=bg, pt.cex=c(1, 1),
       inset=0.02, cex=0.7, box.lty=1, box.lwd=0.5, bg="#FFFFFFCD",
       title=expression(bold("EXPLANATION")))
@

% =========================================================================

\section{Model Configuration}

Something... (\hyperref[fig:map_config]{fig.~\ref{fig:map_config}}).

<<echo=FALSE>>=
wells <- budget[[1]]$d
drain <- budget[[2]]$d
river <- budget[[3]]$d
for (i in 1:3) {
  r <- !is.na(rs[[sprintf("lay%s.bot", i)]])  # inactive and active
  r <- r + 1L

  cells <- cellFromRowCol(r, wells[, "row"], wells[, "column"])
  r[cells[wells[, "layer"] == i & wells[, "id"] == 2]] <- 3  # well
  r[cells[wells[, "layer"] == i & wells[, "id"] == 3]] <- 4  # trib

  cells <- cellFromRowCol(r, river[, "row"], river[, "column"])[river[, "layer"] == i]
  is.well <- r[cells] == 3
  is.trib <- r[cells] == 4
  r[cells[!is.well & !is.trib]] <- 5  # river
  r[cells[is.well]] <- 6  # river + well
  r[cells[is.trib]] <- 7  # river + trib

  cells <- cellFromRowCol(r, drain[, "row"], drain[, "column"])
  r[cells[drain[, "layer"] == i]] <- 8  # drain

  r <- ratify(r)
  idxs <- levels(r)[[1]][, "ID"]
  lab <- c("Inactive", "Active", "Well", "Tributary", "River", "River and well", "River and tributary", "Drain")
  col <- c(NA, "#999999", "#FFF500", "#FF0000", "#00B4FF", "#083769", "#00CDAC", "#FF00CC")
  n <- formatC(vapply(seq_len(8), function(j) sum(r[] == j), 0L), big.mark=",")
  levels(r) <- cbind(levels(r)[[1]], lab=lab[idxs], col=col[idxs], n=n[idxs], stringsAsFactors=FALSE)
  rs[[sprintf("lay%s.config", i)]] <- r
}
@

<<echo=FALSE>>=
FUN <- function(i) {
  r <- rs[[sprintf("lay%s.config", i)]]
  PlotMap(crs(r), xlim=usr.map[1:2], ylim=usr.map[3:4],
          bg.image=hill.shading, bg.image.alpha=0.6,
          dms.tick=TRUE, rivers=list(x=streams.rivers), lakes=list(x=lakes),
          draw.key=FALSE, credit=credit)

  loc <- extent(r)
  rect(loc[1], loc[3], loc[2], loc[4], col="#FFFFFFA6", border=NA)

  buff <- 6L
  loc <- extent(raster(extend(r, buff)))
  rect(loc[1], loc[3], loc[2], loc[4], col=NA, border="black", lwd=0.5)
  d <- levels(r)[[1]]

  labs <- d$lab
  labs[-(1:2)] <- sprintf("%s (n = %s)", labs[-(1:2)], d$n[-(1:2)])
  pt.col <- d$col
  pt.col[1] <- "black"
  legend("topleft", labs, pch=22, col=pt.col, pt.bg=d$col, pt.lwd=0.25, pt.cex=0.8,
         inset=0.02, cex=0.7, box.lty=1, box.lwd=0.5, bg="#FFFFFFE7",
         title=expression(bold("Cell Type")))

  raster::image(r, maxpixels=length(r), useRaster=FALSE, col=col, add=TRUE)

  AddScaleBar(asp=1, "m", loc="topright", offset=c(-0.4, -0.5))
  plt <- c(grconvertX(loc[1:2], "user", "nfc"), grconvertY(loc[3:4], "user", "nfc"))
  par(plt=plt, bg="#FFFFFFCC", new=TRUE)
  m <- seq(0.5 - buff, dim(r)[1] + 0.5 + buff, by=1)
  n <- seq(0.5 - buff, dim(r)[2] + 0.5 + buff, by=1)
  xlim <- range(n)
  ylim <- rev(range(m))
  plot.window(xlim=xlim, ylim=ylim, asp=1, xaxt="n", yaxt="n", xaxs="i", yaxs="i", mar=c(0, 0, 0, 0))

  xat <- pretty(seq_len(dim(r)[2]))
  yat <- pretty(seq_len(dim(r)[1]))
  yat <- seq(min(yat), max(yat), by=diff(xat)[1])
  abline(v=xat, col="#00000023", lwd=0.3)
  abline(h=yat, col="#00000023", lwd=0.3)

  cex <- 0.7
  tcl <- 0.25
  mgp <- c(1, 0.2, 0)
  axis(2, at=yat, tcl=tcl, las=1, cex.axis=cex, lwd=-1, lwd.ticks=0.3, mgp=mgp, font=2)
  axis(3, at=xat, tcl=tcl, las=1, cex.axis=cex, lwd=-1, lwd.ticks=0.3, mgp=mgp, font=2)
  axis(1, at=xat, tcl=tcl, lwd=-1, lwd.ticks=0.3, labels=FALSE, mgp=mgp)
  axis(4, at=yat, tcl=tcl, lwd=-1, lwd.ticks=0.3, labels=FALSE, mgp=mgp)
  mtext("Columns", side=3, line=1, cex=cex, font=2)
  mtext("Rows",    side=2, line=1, cex=cex, font=2)
}
@

\begin{figure}
  \begin{subfigure}{\textwidth}
    \caption{Model layer 1 \label{fig:map_config_a}}
    <<map_config_a, echo=FALSE, results="asis", fig.width=fin.map.0[1], fig.height=fin.map.0[2]>>=
    FUN(1L)
    @
  \end{subfigure}
  \caption{Model domain and locations of boundary condition cell types in (\textit{\textbf{A}}) model layer 1, (\textit{\textbf{B}}) model layer 2, and (\textit{\textbf{C}}) model layer 3.
           All model cells in the active domain of model layer~1 include a water-table boundary condition. \label{fig:map_config}}
\end{figure}

\captionsetup[figure]{list=no}
\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Model layer 2 \label{fig:map_config_b}}
    <<map_config_b, echo=FALSE, results="asis", fig.width=fin.map.0[1], fig.height=fin.map.0[2]>>=
    FUN(2L)
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}

\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Model layer 3 \label{fig:map_config_c}}
    <<map_config_c, echo=FALSE, results="asis", fig.width=fin.map.0[1], fig.height=fin.map.0[2]>>=
    FUN(3L)
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}
\captionsetup[figure]{list=yes}

% =========================================================================

\section{Groundwater Flow Across the Water-Table}

Something... (\hyperref[fig:graph_areal_rech]{fig.~\ref{fig:graph_areal_rech}}).

<<graph_areal_rech, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2], fig.cap="{Total areal recharge.}">>=
d <- TidyBudget(b, "wells", 1L)[, c("totim.date", "flow.total", "flow.total")]
d[d[, 2] < 0, 2] <- 0
d[d[, 3] > 0, 3] <- 0
ylab <- paste("Total areal recharge, in", c("cubic meters per day", "acre-feet per year"))
col <- c("#67A9CF", "#C80C0B")
PlotGraph(d, ylab=ylab, col=col, fill=paste0(col, "66"),
          conversion.factor=m3.per.d.to.af.per.yr, scientific=TRUE,
          center.date.labels=TRUE, seq.date.by="year")
legend("topright", c("Recharge", "Discharge"), col=col, lty=1,
       inset=0.02, cex=0.7, box.lty=1, box.lwd=0.5, bg="#FFFFFFE7")
@

Descriptive statistics for areal recharge rates, in cubic meters per day:

<<echo=FALSE>>=
summary(round(TidyBudget(b, "wells", 1L)$flow.total))
@

% =========================================================================

\section{Groundwater Diversions}

Something... (\hyperref[fig:graph_wells]{fig.~\ref{fig:graph_wells}}).

<<graph_wells, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2], fig.cap="{Total groundwater withdrawals from production wells in the model domain.}">>=
d <- TidyBudget(b, "wells", 2L)[, c("totim.date", "flow.total", "flow.total")]
ylab <- paste("Total withdrawals from wells, in", c("cubic meters per day", "acre-feet per year"))
col <- "#C80C0B"
PlotGraph(d, ylab=ylab, col=col, fill=paste0(col, "66"),
          conversion.factor=m3.per.d.to.af.per.yr, scientific=TRUE,
          center.date.labels=TRUE, seq.date.by="year")
@

Descriptive statistics for pumping rates, in cubic meters per day:

<<echo=FALSE>>=
summary(round(TidyBudget(b, "wells", 2L)$flow.total))
@

% =========================================================================

\section{Hydraulic Conductivity}

Hydraulic conductivity ($K$) is a property of soils and rocks, that describes the ease with which water can move through pore spaces or fractures
(\hyperref[table_hk]{table~\ref{table_hk}}; \hyperref[fig:map_hk]{figs.~\ref{fig:map_hk}} and \ref{fig:cs_hk}).

<<echo=FALSE>>=
x <- readLines(file.path(path, "wrv_mfusg.lpf"))
x <- x[substr(x, 1, 14)  == "VERTANISO VANI"]
vani <- suppressWarnings(na.omit(as.numeric(strsplit(x, " ")[[1]])))[1]

r <- ReadRef("hk1.ref")
names(r) <- "lay1.hk"
rs <- stack(rs, r)

r <- ReadRef("hk2.ref")
names(r) <- "lay2.hk"
rs <- stack(rs, r)

r <- ReadRef("hk3.ref")
names(r) <- "lay3.hk"
rs <- stack(rs, r)

x <- c(rs[["lay1.hk"]][], rs[["lay2.hk"]][], rs[["lay3.hk"]][])
breaks <- pretty(log10(x), n=15, na.rm=TRUE)

at <- breaks[c(TRUE, FALSE)]
labels <- ToScientific(10^at, digits=1, type="plotmath")

Pal <- function(...) viridisLite::viridis(...)
FUN <- function(r) {
  r[] <- log10(r[])
  PlotMap(r, breaks=breaks, xlim=usr.map[1:2], ylim=usr.map[3:4],
          bg.image=hill.shading, bg.image.alpha=0.6, dms.tick=TRUE,
          pal=Pal, explanation="Horizontal hydraulic conductivity, in meters per day, plotted on a logarithmic scale.",
          rivers=list(x=streams.rivers), lakes=list(x=lakes),
          labels=list(at=at, labels=labels), credit=credit,
          scale.loc="bottomleft")
  lines(transect, col="#1F1F1F")
  text(transect.ends, labels=c("A", "A'"), col="#1F1F1F", cex=0.7, pos=c(3, 4), offset=0.1, font=4)
  plot(cities, pch=15, cex=0.8, col="#333333", add=TRUE)
  text(cities, labels=cities@data$FEATURE_NA, col="#333333", cex=0.5, pos=1, offset=0.4)
  leg <- "Line of cross section"
  legend("topright", leg, lwd=1, col="#1F1F1F", inset=0.02, cex=0.7, box.lty=1,
         box.lwd=0.5, bg="#FFFFFFE7")
}
@

\begin{figure}
  \begin{subfigure}{\textwidth}
    \caption{Model layer 1 \label{fig:map_hk_a}}
    <<map_hk_a, echo=FALSE, results="asis", fig.width=fin.map[1], fig.height=fin.map[2]>>=
    FUN(rs[["lay1.hk"]])
    @
  \end{subfigure}
  \caption{Spatial distribution of the hydraulic conductivity in (\textit{\textbf{A}}) model layer 1, (\textit{\textbf{B}}) model layer 2, and (\textit{\textbf{C}}) model layer 3. \label{fig:map_hk}}
\end{figure}

\captionsetup[figure]{list=no}
\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Model layer 2 \label{fig:map_hk_b}}
    <<map_hk_b, echo=FALSE, results="asis", fig.width=fin.map[1], fig.height=fin.map[2]>>=
    FUN(rs[["lay2.hk"]])
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}

\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Model layer 3 \label{fig:map_hk_c}}
    <<map_hk_c, echo=FALSE, results="asis", fig.width=fin.map[1], fig.height=fin.map[2]>>=
    FUN(rs[["lay3.hk"]])
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}
\captionsetup[figure]{list=yes}

<<cs_hk, echo=FALSE, fig.width=fin.cs[1], fig.height=fin.cs[2], fig.cap="{Vertical cross-section of horizontal hydraulic conductivities along the line of cross section A--A'.}">>=
geo.lays <- c("lay1.top", paste0("lay", 1:3, ".bot"))
val.lays <- paste0("lay", 1:3, ".hk")
rs.log <- rs
rs.log[["lay1.hk"]][] <- log10(rs.log[["lay1.hk"]][])
rs.log[["lay2.hk"]][] <- log10(rs.log[["lay2.hk"]][])
rs.log[["lay3.hk"]][] <- log10(rs.log[["lay3.hk"]][])
PlotCrossSection(transect, rs.log, geo.lays, val.lays, asp=80, breaks=breaks, pal=Pal,
                 ylab="Elevation, in meters above the North American Vertical Datum of 1988",
                 unit="METERS", features=cities[, "FEATURE_NA"], max.feature.dist=4000, is.categorical=FALSE,
                 explanation="Horizontal hydraulic conductivity in meters per day, plotted on a logarithmic scale.",
                 draw.sep=FALSE, labels=list(at=at, labels=labels))
@

<<echo=FALSE>>=
r <- raster(rs)
cells <- which(rs[["lay1.zones"]][] == 1L)
r[cells] <- rs[["lay1.hk"]][cells]
names(r) <- "lay1.hk.zone1"  # hk, layer 1, unconfined alluvium
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay2.zones"]][] == 1L)
r[cells] <- rs[["lay2.hk"]][cells]
names(r) <- "lay2.hk.zone1"  # hk, layer 2, unconfined alluvium
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay2.zones"]][] == 2L)
r[cells] <- rs[["lay2.hk"]][cells]
names(r) <- "lay2.hk.zone2"  # hk, layer 2, basalt
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay2.zones"]][] == 3L)
r[cells] <- rs[["lay2.hk"]][cells]
names(r) <- "lay2.hk.zone3"  # hk, layer 2, clay
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay3.zones"]][] == 1L)
r[cells] <- rs[["lay3.hk"]][cells]
names(r) <- "lay3.hk.zone1"  # hk, layer 3, unconfined alluvium
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay3.zones"]][] == 2L)
r[cells] <- rs[["lay3.hk"]][cells]
names(r) <- "lay3.hk.zone2"  # hk, layer 3, basalt
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay3.zones"]][] == 4L)
r[cells] <- rs[["lay3.hk"]][cells]
names(r) <- "lay3.hk.zone4"  # hk, layer 3, confined alluvium
rs <- stack(rs, r)
@

<<table_hk, echo=FALSE, results="asis">>=
d <- cbind(summary(rs[["lay1.hk.zone1"]][]),
           summary(rs[["lay2.hk.zone1"]][]),
           summary(rs[["lay3.hk.zone1"]][]),
           summary(rs[["lay2.hk.zone2"]][]),
           summary(rs[["lay3.hk.zone2"]][]),
           summary(rs[["lay2.hk.zone3"]][]),
           summary(rs[["lay3.hk.zone4"]][]))
d <- d[-nrow(d), ]
columns <- c("Zone 1 \\\\ Layer 1 \\\\ (m/d)",
             "Zone 1 \\\\ Layer 2 \\\\ (m/d)",
             "Zone 1 \\\\ Layer 3 \\\\ (m/d)",
             "Zone 2 \\\\ Layer 2 \\\\ (m/d)",
             "Zone 2 \\\\ Layer 3 \\\\ (m/d)",
             "Zone 3 \\\\ Layer 2 \\\\ (m/d)",
             "Zone 4 \\\\ Layer 3 \\\\ (m/d)")
colnames(d) <- sprintf("\\textbf{\\shortstack{%s}}", columns)
dd <- apply(d, 2, ToScientific, digits=1)
rownames(dd) <- c("Minimum", "1\\textsuperscript{st} quartile", "Median", "Mean",
                  "3\\textsuperscript{rd} quartile", "Maximum")
cap1 <- "Descriptive statistics for the calibrated vales of horizontal hydraulic conductivity."
cap2 <- c("\\textbf{Zone~1}: is hydrogeologic zone~1 consisting of the alluvium hydrogeologic unit (unit) in the unconfined aquifer.",
          "\\textbf{Zone~2}: comprises the basalt and clay units.",
          "\\textbf{Zone~3}: consists of the clay confining unit.",
          "\\textbf{Zone~4}: consists of the alluvium unit in the confined aquifer.",
          "\\textbf{Layer}: is the model layer.",
          "\\textbf{Abbreviations}: m/d, meters per day")
tbl <- xtable::xtable(dd, label="table_hk")
xtable::caption(tbl) <- c(sprintf("%s [%s]", cap1, paste(cap2, collapse=" ")), cap1)
xtable::align(tbl) <- c("r", rep("l", ncol(d)))
print(tbl, include.rownames=TRUE, caption.placement="top", booktabs=TRUE,
      format.args=list(big.mark=","), sanitize.colnames.function=function(x){x},
      sanitize.text.function=identity, size="\\small")
@

The ratio of horizontal to vertical hydraulic conductivity (vertical anisotropy) is \Sexpr{formatC(vani, digits=2, format="f")}.

% =========================================================================

\section{Storage Coefficient}

Storage coefficient ($S$) (\hyperref[table_sc]{table~\ref{table_sc}}; \hyperref[fig:map_sc]{figs.~\ref{fig:map_sc}} and \ref{fig:cs_sc}).

<<echo=FALSE>>=
r <- ReadRef("ss1.ref")
names(r) <- "lay1.sc"
rs <- stack(rs, r)

r <- ReadRef("ss2.ref")
names(r) <- "lay2.sc"
rs <- stack(rs, r)

r <- ReadRef("ss3.ref")
names(r) <- "lay3.sc"
rs <- stack(rs, r)

x <- c(rs[["lay1.sc"]][], rs[["lay2.sc"]][], rs[["lay3.sc"]][])
breaks <- pretty(log10(x), n=15, na.rm=TRUE)
labels <- ToScientific(10^breaks, digits=1, type="plotmath")
Pal <- colorRampPalette(c("#4dac26", "#b8e186", "#f7f7f7", "#f1b6da", "#d01c8b"))
FUN <- function(r) {
  r[] <- log10(r[])
  PlotMap(r, breaks=breaks, xlim=usr.map[1:2], ylim=usr.map[3:4],
          bg.image=hill.shading, bg.image.alpha=0.6, dms.tick=TRUE,
          pal=Pal, explanation="Storage coefficient, a dimensionless quantity, plotted on a logarithmic scale.",
          rivers=list(x=streams.rivers), lakes=list(x=lakes),
          labels=list(at=breaks, labels=labels), credit=credit,
          scale.loc="bottomleft")
  lines(transect, col="#1F1F1F")
  text(transect.ends, labels=c("A", "A'"), col="#1F1F1F", cex=0.7, pos=c(3, 4), offset=0.1, font=4)
  plot(cities, pch=15, cex=0.8, col="#333333", add=TRUE)
  text(cities, labels=cities@data$FEATURE_NA, col="#333333", cex=0.5, pos=1, offset=0.4)
  leg <- "Line of cross section"
  legend("topright", leg, lwd=1, col="#1F1F1F", inset=0.02, cex=0.7, box.lty=1,
         box.lwd=0.5, bg="#FFFFFFE7")
}
@

\begin{figure}
  \begin{subfigure}{\textwidth}
    \caption{Model layer 1 \label{fig:map_sc_a}}
    <<map_sc_a, echo=FALSE, results="asis", fig.width=fin.map[1], fig.height=fin.map[2]>>=
    FUN(rs[["lay1.sc"]])
    @
  \end{subfigure}
  \caption{Spatial distribution of the storage coefficient in (\textit{\textbf{A}}) model layer 1, (\textit{\textbf{B}}) model layer 2, and (\textit{\textbf{C}}) model layer 3. \label{fig:map_sc}}
\end{figure}

\captionsetup[figure]{list=no}
\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Model layer 2 \label{fig:map_sc_b}}
    <<map_sc_b, echo=FALSE, results="asis", fig.width=fin.map[1], fig.height=fin.map[2]>>=
    FUN(rs[["lay2.sc"]])
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}

\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Model layer 3 \label{fig:map_sc_c}}
    <<map_sc_c, echo=FALSE, results="asis", fig.width=fin.map[1], fig.height=fin.map[2]>>=
    FUN(rs[["lay3.sc"]])
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}
\captionsetup[figure]{list=yes}

<<cs_sc, echo=FALSE, fig.width=fin.cs[1], fig.height=fin.cs[2], fig.cap="{Vertical cross-section of storage coefficients along the line of cross section A--A'.}">>=
geo.lays <- c("lay1.top", paste0("lay", 1:3, ".bot"))
val.lays <- paste0("lay", 1:3, ".sc")
rs.log <- rs
rs.log[["lay1.sc"]][] <- log10(rs.log[["lay1.sc"]][])
rs.log[["lay2.sc"]][] <- log10(rs.log[["lay2.sc"]][])
rs.log[["lay3.sc"]][] <- log10(rs.log[["lay3.sc"]][])
PlotCrossSection(transect, rs.log, geo.lays, val.lays, asp=80, breaks=breaks, pal=Pal,
                 ylab="Elevation, in meters above the North American Vertical Datum of 1988",
                 unit="METERS", features=cities[, "FEATURE_NA"], max.feature.dist=4000, is.categorical=FALSE,
                 explanation="Storage coefficient, a dimensionless quantity, plotted on a logarithmic scale.",
                 draw.sep=FALSE, labels=list(at=breaks, labels=labels))
@

<<echo=FALSE>>=
r <- raster(rs)
cells <- which(rs[["lay1.zones"]][] == 1L)
r[cells] <- rs[["lay1.sc"]][cells]
names(r) <- "lay1.sc.zone1"  # sc, layer 1, unconfined alluvium
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay2.zones"]][] == 1L)
r[cells] <- rs[["lay2.sc"]][cells]
names(r) <- "lay2.sc.zone1"  # sc, layer 2, unconfined alluvium
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay2.zones"]][] == 2L)
r[cells] <- rs[["lay2.sc"]][cells]
names(r) <- "lay2.sc.zone2"  # sc, layer 2, basalt
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay2.zones"]][] == 3L)
r[cells] <- rs[["lay2.sc"]][cells]
names(r) <- "lay2.sc.zone3"  # sc, layer 2, clay
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay3.zones"]][] == 1L)
r[cells] <- rs[["lay3.sc"]][cells]
names(r) <- "lay3.sc.zone1"  # sc, layer 3, unconfined alluvium
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay3.zones"]][] == 2L)
r[cells] <- rs[["lay3.sc"]][cells]
names(r) <- "lay3.sc.zone2"  # sc, layer 3, basalt
rs <- stack(rs, r)

r <- raster(rs)
cells <- which(rs[["lay3.zones"]][] == 4L)
r[cells] <- rs[["lay3.sc"]][cells]
names(r) <- "lay3.sc.zone4"  # sc, layer 3, confined alluvium
rs <- stack(rs, r)
@

<<table_sc, echo=FALSE, results="asis">>=
d <- cbind(summary(rs[["lay1.sc.zone1"]][]),
           summary(rs[["lay2.sc.zone1"]][]),
           summary(rs[["lay3.sc.zone1"]][]),
           summary(rs[["lay2.sc.zone2"]][]),
           summary(rs[["lay3.sc.zone2"]][]),
           summary(rs[["lay2.sc.zone3"]][]),
           summary(rs[["lay3.sc.zone4"]][]))
d <- d[-nrow(d), ]
columns <- c("Zone 1 \\\\ Layer 1 \\\\ (1)",
             "Zone 1 \\\\ Layer 2 \\\\ (1)",
             "Zone 1 \\\\ Layer 3 \\\\ (1)",
             "Zone 2 \\\\ Layer 2 \\\\ (1)",
             "Zone 2 \\\\ Layer 3 \\\\ (1)",
             "Zone 3 \\\\ Layer 2 \\\\ (1)",
             "Zone 4 \\\\ Layer 3 \\\\ (1)")
colnames(d) <- sprintf("\\textbf{\\shortstack{%s}}", columns)
dd <- apply(d, 2, ToScientific, digits=1)
rownames(dd) <- c("Minimum", "1\\textsuperscript{st} quartile", "Median", "Mean",
                  "3\\textsuperscript{rd} quartile", "Maximum")
cap1 <- "Descriptive statistics for calibrated values of storage coefficient, a dimensionless quantity."
cap2 <- c("\\textbf{Zone~1}: is hydrogeologic zone~1 consisting of the alluvium hydrogeologic unit (unit) in the unconfined aquifer.",
          "\\textbf{Zone~2}: comprises the basalt and clay units.",
          "\\textbf{Zone~3}: consists of the clay confining unit.",
          "\\textbf{Zone~4}: consists of the alluvium unit in the confined aquifer.",
          "\\textbf{Layer}: is the model layer.")
tbl <- xtable::xtable(dd, label="table_sc")
xtable::caption(tbl) <- c(sprintf("%s [%s]", cap1, paste(cap2, collapse=" ")), cap1)
xtable::align(tbl) <- c("r", rep("l", ncol(d)))
print(tbl, include.rownames=TRUE, caption.placement="top", booktabs=TRUE,
      format.args=list(big.mark=","), sanitize.colnames.function=function(x){x},
      sanitize.text.function=identity, size="\\small")
@

% =========================================================================

\section{Irrigation Efficiency}

<<echo=FALSE>>=
d <- read.csv(file.path(path, "eff.csv"), colClasses=c("character", "numeric"))
d$id <- seq_len(nrow(d))
p <- irr.entities
p@data <- suppressWarnings(dplyr::left_join(p@data, d, by="EntityName"))
p1 <- p[p@data$Source != "SW Only", ]
p2 <- p[p@data$Source == "SW Only", ]
d$is.gw <- d$id %in% p1@data$id
@

Irrigation efficiency ($\mathit{eff}$) the ratio between irrigation water actually utilized by growing plants and the total water diverted from sources
in order to supply such irrigation water (\hyperref[table_eff]{table~\ref{table_eff}}, \hyperref[fig:map_eff]{fig.~\ref{fig:map_eff}}).

<<table_eff, echo=FALSE, results="asis">>=
dd <- d[, c("EntityName", "id", "Eff")]
dd$Eff <- format(dd$Eff, digits=2)
dd$Eff[d$is.gw] <- sprintf("\\textbf{%s}", dd$Eff[d$is.gw])
n <- nrow(dd) / 2
dd <- data.frame(dd[1:n, ], dd[(n + 1L):nrow(dd), ])
columns <- rep(c("Irrigation entity", "Entity \\\\ No.", "Eff \\\\ (1)"), 2)
colnames(dd) <- sprintf("\\textbf{\\shortstack{%s}}", columns)
cap1 <- "Calibrated values of irrigation efficiency applied to their respective irrigation entity."
cap2 <- c("\\textbf{Irrigation entity}: local name used in this study.",
          "\\textbf{Entity No.}: an identifier used to locate the irrigation entity on the map in figure~10.",
          "\\textbf{Eff}: the irrigation efficiency, a dimensionless quantity. Entry in \\textbf{bold} indicates a calibrated value.")
tbl <- xtable::xtable(dd, label="table_eff")
xtable::caption(tbl) <- c(sprintf("%s [%s]", cap1, paste(cap2, collapse=" ")), cap1)
xtable::align(tbl) <- "rlcc|lcc"
print(tbl, include.rownames=FALSE, caption.placement="top", booktabs=TRUE,
      format.args=list(big.mark=","), sanitize.colnames.function=function(x){x},
      sanitize.text.function=identity, size="\\small")
@

<<map_eff, echo=FALSE, fig.width=fin.map[1], fig.height=fin.map[2], fig.cap="{Calibrated irrigation efficiencies for irrigation entities with groundwater sources.}">>=
r <- rasterize(p1, raster(rs), "Eff")
Pal <- colorRampPalette(c("#FFFFCCCC", "#C2E699CC", "#78C679CC", "#31A354CC", "#006837CC"), alpha=TRUE)
breaks <- pretty(r[], n=20, na.rm=TRUE)
labels <- formatC(breaks)
PlotMap(r, breaks=breaks, xlim=usr.map[1:2], ylim=usr.map[3:4],
        bg.image=hill.shading, bg.image.alpha=0.6, dms.tick=TRUE,
        pal=Pal, explanation="Irrigation efficiency, a dimensionless quantity.",
        rivers=list(x=streams.rivers), lakes=list(x=lakes),
        labels=list(at=breaks, labels=labels), credit=credit,
        scale.loc="bottomleft", draw.raster=FALSE)
cols <- Pal(max(p1@data$id))
plot(p1, col=cols[p1@data$id], border=NA, add=TRUE)
plot(p2, col="#948979", border=NA, add=TRUE)
plot(alluvium.extent, border="#3030307F", add=TRUE)
plot(cities, pch=15, cex=0.8, col="#333333", add=TRUE)
text(cities, labels=cities@data$FEATURE_NA, col="#333333", cex=0.5, pos=1, offset=0.4)
legend("topright", "Irrigation entity with no groundwater source", fill="#948979", border=NA,
       inset=0.02, cex=0.7, box.lty=1, box.lwd=0.5, xpd=NA, bg="#FFFFFFCD")
@

Descriptive statistics for the calibrated values of irrigation efficiency, a dimensionless quantity specified per irrigation entity:

<<echo=FALSE>>=
summary(d$Eff[d$is.gw], digits=2)
@

% =========================================================================

\section{Riverbed Conductance}

<<echo=FALSE>>=
con <- file(file.path(path, "wrv_mfusg.riv"), "r")
mxactr <- NULL
while(length(mxactr) == 0)
  mxactr <- scan(con, comment.char="#", strip.white=TRUE, n=1, nlines=1, quiet=TRUE)
d <- read.table(con, skip=2, nrows=mxactr)
close(con)
colnames(d) <- c("Layer", "Row", "Column", "Stage", "Condfact", "Rbot", "ReachNo")
r <- raster(rs)
cells <- cellFromRowCol(raster(rs), d$Row, d$Col)
r[cells] <- d$Condfact
names(r) <- "riv.cond"
rs <- stack(rs, r)
@

Riverbed conductance is a property of riverbed sediments and that describes the ease with which water seeps through pore spaces
(\hyperref[table_riv_cond]{table~\ref{table_riv_cond}}, \hyperref[fig:map_riv_cond]{fig.~\ref{fig:map_riv_cond}}).

Descriptive statistics for the calibrated values of riverbed conductance in square meters per day:

<<echo=FALSE>>=
summary(d$Condfact, digits=1)
@

<<table_riv_cond, echo=FALSE, results="asis">>=
d <- aggregate(d[, "Condfact"], by=list(ReachNo=d$ReachNo), mean)
names(d) <- c("ReachNo", "Condfact")
idxs <- match(d$ReachNo, river.reaches@data$ReachNo)
d <- cbind(d, river.reaches@data[idxs, c("BigReach", "Reach")])
reach.no <- as.character(d$BigReach)
reach.no[reach.no == "None"] <- NA
reach.no <- as.integer(factor(reach.no, levels=unique(reach.no)))
d$BigReachNo <- reach.no
d <- d[, c("Reach", "ReachNo", "BigReachNo", "Condfact")]
columns <- c("River subreach",
             "Subreach \\\\ No.",
             "Reach \\\\ No.",
             "Riverbed \\\\ conductance \\\\ (m\\textsuperscript{2}/d)")
colnames(d) <- sprintf("\\textbf{\\shortstack{%s}}", columns)
cap1 <- "Calibrated values of riverbed conductance in river subreaches of the Wood River Valley, Idaho."
cap2 <- c("\\textbf{Subreach No.}: is an identifier used to locate river subreaches on the map in \\hyperref[fig:map_riv_cond]{figure~\\ref{fig:map_riv_cond}}.",
          "\\textbf{Reach No.}: is an identifier for river reaches.",
          "\\textbf{Riverbed conductance}: is the average hydraulic conductance of the riverbed sediments.",
          "\\textbf{Abbreviations}: m\\textsuperscript{2}/d, square meters per day;  --, a river subreach that is not associated with a river reach")
tbl <- xtable::xtable(d, label="table_riv_cond")
xtable::caption(tbl) <- c(sprintf("%s [%s]", cap1, paste(cap2, collapse=" ")), cap1)
xtable::digits(tbl) <- 0
print(tbl, include.rownames=FALSE, caption.placement="top", booktabs=TRUE,
      format.args=list(big.mark=","), sanitize.colnames.function=function(x){x},
      sanitize.text.function=identity, size="\\small", NA.string="--")
@

<<map_riv_cond, echo=FALSE, fig.width=fin.map[1], fig.height=fin.map[2], fig.cap="{Spatial distribution of riverbed conductance in the model domain. River subreach identifiers are used as a cross reference with data in \\hyperref[table_riv_cond]{table~\\ref{table_riv_cond}}}">>=
r <- rs[["riv.cond"]]
breaks <- pretty(log10(r[]), n=15, na.rm=TRUE)
labels <- ToScientific(10^breaks, digits=1, type="plotmath")
Pal <- colorRampPalette(c("#2c7bb6", "#FBB829", "#d7191c"))
r[] <- log10(r[])
PlotMap(r, breaks=breaks, xlim=usr.map[1:2], ylim=usr.map[3:4],
        bg.image=hill.shading, bg.image.alpha=0.6, dms.tick=TRUE,
        pal=Pal, explanation="Riverbed conductance, in square meters per day, plotted on a logarithmic scale.",
        labels=list(at=breaks, labels=labels), credit=credit, scale.loc="bottomleft")
pos <- c(4, 4, 4, 4, 4, 4, 4, 2, 2, 2,
         3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
         1, 3)
text(getSpatialLinesMidPoints(river.reaches), labels=river.reaches@data$ReachNo,
     col="#333333", cex=0.6, pos=pos, offset=0.4)
bwr.gages <- streamgages[streamgages@data$SiteNo %in% c("13140800", "13139510", "13135500"), ]
points(bwr.gages, pch=17, col="#333333")
text(bwr.gages, labels=bwr.gages@data$SiteNo, col="#333333", cex=0.6, pos=2)
plot(cities, pch=15, cex=0.8, col="#333333", add=TRUE)
text(cities, labels=cities@data$FEATURE_NA, col="#333333", cex=0.5, pos=1, offset=0.4)
@

% =========================================================================

\section{Drain Conductance}

Something... (\hyperref[table_drains]{table~\ref{table_drains}}).

<<echo=FALSE>>=
con <- file(file.path(path, "wrv_mfusg.drn"), "r")
mxactd <- NULL
while(length(mxactd) == 0)
  mxactd <- scan(con, comment.char="#", strip.white=TRUE, n=1, nlines=1, quiet=TRUE)
d <- read.table(con, skip=2, nrows=mxactd)
colnames(d) <- c("Layer", "Row", "Column", "Elevation", "Condfact", "id")
close(con)
@

<<table_drains, echo=FALSE, results="asis">>=
is.1 <- d$id == 1L
is.2 <- d$id == 2L
idxs <- c(which(is.1)[1], which(is.2 & d$Layer == 1L)[1],
          which(is.2 & d$Layer == 2L)[1], which(is.2 & d$Layer == 3L)[1])
dd <- data.frame(c("Stanton Crossing", "Silver Creek", "", ""),
                 c(1, 1, 2, 3), d[idxs, c("Condfact", "Elevation")])
dd$Condfact <- ToScientific(dd$Condfact, digits=1)
columns <- c("Outlet \\\\ boundary",
             "Model \\\\ layer",
             "Drain \\\\ conductance \\\\ (m\\textsuperscript{2}/d)",
             "Elevation \\\\ threshold \\\\ (m)")
colnames(dd) <- sprintf("\\textbf{\\shortstack{%s}}", columns)
cap1 <- "Drain conductance and elevation threshold for groundwater outlet boundaries."
cap2 <- c("\\textbf{Drain conductance}: is the hydraulic conductance of the interface between the aquifer and the drain.",
          "\\textbf{Elevation threshold}: is the elevation of the drain.",
          "\\textbf{Abbreviations}: m\\textsuperscript{2}/d, square meters per day; m, meters above the North American Vertical Datum of 1988")
tbl <- xtable::xtable(dd, label="table_drains")
xtable::caption(tbl) <- c(sprintf("%s [%s]", cap1, paste(cap2, collapse=" ")), cap1)
xtable::align(tbl) <- "llclc"
xtable::digits(tbl)[c(3, 5)] <- 0
print(tbl, include.rownames=FALSE, caption.placement="top", booktabs=TRUE,
      format.args=list(big.mark=","), sanitize.colnames.function=function(x){x},
      sanitize.text.function=identity, size="\\small")
@

% =========================================================================

\section{Tributary Basin Underflow}

Something... (\hyperref[table_tribs]{table~\ref{table_tribs}}; \hyperref[fig:map_tribs]{figs.~\ref{fig:map_tribs}} and \ref{fig:cs_sc}).

<<echo=FALSE>>=
d <- read.csv(file.path(path, "trib.csv"))
reduction   <- d$Value[d$Name == "reduction"]
d.in.mv.ave <- d$Value[d$Name == "d.in.mv.ave"]
scale.factors <- head(d$Value, -2)
names(scale.factors) <- head(d$Name, -2)
mult <- GetSeasonalMult(gage.disch[, c("Date", "13139510")], reduction, d.in.mv.ave, tr.stress.periods)
mult <- data.frame(head(tr.stress.periods, -1), rep(mult$multiplier, each=3))
names(mult) <- c("Date", "multiplier")
FUN <- function(i) mult$multiplier * i
flow   <- t(vapply(tributaries$Flow * scale.factors, FUN, rep(0, nrow(mult))))
colnames(flow) <- format(mult$Date, format = "%Y%m")
rownames(flow) <- tributaries$Name

l <- rgeos::gIntersection(as(tributaries, "SpatialLinesDataFrame"), alluvium.extent, TRUE)
trib.lines <- SpatialLinesDataFrame(l, data = tributaries@data, match.ID = FALSE)
d <- data.frame(Name=tributaries$Name, mean.flow=tributaries$Flow * scale.factors)
trib.lines@data <- dplyr::left_join(trib.lines@data, d, by="Name")
r <- rasterize(trib.lines, raster(rs), "mean.flow")
@

Calibrated values of the moving average and amplitude reduction factor are \Sexpr{formatC(d.in.mv.ave, digits=1, format="f")} days and \Sexpr{formatC(reduction, digits=1, format="f")}.

<<table_tribs, echo=FALSE, results="asis">>=
d <- data.frame(name=tributaries$Name,
                idxs=seq_len(length(tributaries)),
                start=tributaries$Flow,
                lower=tributaries$Flow * 0.01,
                upper=tributaries$PrecipFlow * 0.2,
                mean.flow=tributaries$Flow * scale.factors,
                mean.flow.af=tributaries$Flow * scale.factors * m3.per.d.to.af.per.yr)
columns <- c("Tributary \\\\ canyon",
             "Trib. \\\\ No.",
             "Starting \\\\ (m\\textsuperscript{3}/d)",
             "Lower \\\\ bound \\\\ (m\\textsuperscript{3}/d)",
             "Upper \\\\ bound \\\\ (m\\textsuperscript{3}/d)",
             "Calibrated \\\\ (m\\textsuperscript{3}/d)",
             "Calibrated \\\\ (acre-ft/yr)")
colnames(d) <- sprintf("\\textbf{\\shortstack{%s}}", columns)
cap1 <- "Long-term mean volumetric flow rate for groundwater entering the model domain in the major tributary canyons and the upper part of the Wood River Valley, Idaho."
cap2 <- c("\\textbf{Trib. No.}: is an identifier used to locate the tributary boundaries on the map in figure 7.",
          "\\textbf{Starting}: is the starting value used in calibration for the mean volumetric flow rate during the period of transient model simulation (1995--2010) for groundwater entering the model domain at the tributary boundary.",
          "\\textbf{Upper} and \\textbf{Lower bound}: is the specified range for volumetric flow rate parameter values during the model-calibration process.",
          "\\textbf{Calibrated}: is the calibrated volumetric flow rate value.",
          "\\textbf{Abbreviations}: m\\textsuperscript{3}/d, cubic meters per day; acre-ft/yr, acre-feet per year")
tbl <- xtable::xtable(d, label="table_tribs")
xtable::caption(tbl) <- c(sprintf("%s [%s]", cap1, paste(cap2, collapse=" ")), cap1)
xtable::digits(tbl) <- 0
print(tbl, include.rownames=FALSE, caption.placement="top", booktabs=TRUE,
      format.args=list(big.mark=","), sanitize.colnames.function=function(x){x},
      size="\\small")
@

<<map_tribs, echo=FALSE, fig.width=fin.map.0[1], fig.height=fin.map.0[2], fig.cap="{Spatial distribution of long-term mean volumetric flow rate for groundwater entering the model domain in the major tributary canyons and the upper part of the Wood River Valley, Idaho. Tributary identifiers are used as a cross reference with data in table 3.}">>=
PlotMap(crs(hill.shading), xlim=usr.map[1:2], ylim=usr.map[3:4],
        bg.image=hill.shading, bg.image.alpha=0.6, dms.tick=TRUE,
        rivers=list(x=streams.rivers), lakes=list(x=lakes), credit=credit,
        scale.loc="bottomleft")
plot(alluvium.extent, border="#FFFFFFCC", add=TRUE)
xy <- coordinates(getSpatialLinesMidPoints(trib.lines))
z <- trib.lines@data$mean.flow
Pal <- function(...) rev(viridisLite::viridis(..., alpha=0.8))
AddPoints(xy, z=z, inches=c(0.03, 0.3), fg="#FFFFFF65", format="d",
          title="Average groundwater flow rate", subtitle="in cubic meters per day",
          bg=Pal, legend.loc="topright", quantile.breaks=TRUE)
plot(cities, pch=15, cex=0.8, col="#333333", add=TRUE)
text(cities, labels=cities@data$FEATURE_NA, col="#333333", cex=0.5, pos=1, offset=0.4)
text(xy, labels=rownames(trib.lines@data), col="#333333", cex=0.6, adj=c(0.5, 0.5), offset=0)
@

<<graph_tribs, echo=FALSE, fig.width=fin.graph[1], fig.height=fin.graph[2], fig.cap="{Recharge from major tributary canyons and the upper part of the Wood River Valley, Idaho.}">>=
d <- data.frame(mult$Date, t(flow))
d <- d[, c(1, sort(apply(d[, -1], 2, mean), decreasing=TRUE, index.return=TRUE)$ix + 1L)]
ndays <- GetDaysInMonth(tail(rownames(d), 1))
d <- rbind(d, d[nrow(d), , drop=FALSE])
d[nrow(d), 1] <- d[nrow(d), 1] + ndays
ylab <- paste("Tributary basin underflow, in", c("cubic meters per day", "acre-feet per year"))
cols  <- rainbow(ncol(d), start=0.0, end=0.8)
PlotGraph(d, ylab=ylab, conversion.factor=m3.per.d.to.af.per.yr, col=cols,
          scientific=TRUE, center.date.labels=TRUE, seq.date.by="year")
leg <- format(match(colnames(d)[-1], make.names(tributaries@data$Name)))
legend("topright", leg, lwd=1, col=cols, ncol=2,
       pt.cex=1, inset=0.02, cex=0.7, box.lty=1, box.lwd=0.5,
       bg="#FFFFFFE7", title=expression(bold("Tributary")))
@

\clearpage

% =========================================================================

\section{Sensitivity Analysis}

Something... (\hyperref[table_sen]{table~\ref{table_sen}}; \hyperref[fig:graph_sen]{fig.~\ref{fig:graph_sen}}).

<<echo=FALSE>>=
sensitivity$rank <- as.integer(rank(-sensitivity$rel.comp.sens))

PrintTable <- function(idxs, is.last.hline, label) {
  d <- sensitivity[idxs[idxs <= nrow(sensitivity)], ]

  d$desc <- as.character(d$parameter.desc)
  d$units <- as.character(d$units)
  d$units[d$units == ""] <- "1"
  d$units[d$units == "m2/d"] <- "m\\textsuperscript{2}/d"
  d$desc <- sprintf("%s (%s)", d$desc, d$units)
  d[duplicated(d[, "desc"]), "desc"] <- ""

  d$lower.bound <- signif(d$lower.bound, 2)
  d$upper.bound <- signif(d$upper.bound, 2)
  d$start.value <- signif(d$start.value, 2)
  d$value       <- signif(d$value, 2)

  is.lower <- d$lower.bound == d$value
  is.upper <- d$upper.bound == d$value
  is.start <- d$start.value == d$value
  is.value <- is.lower | is.upper | is.start

  d$lower.bound   <- ToScientific(d$lower.bound,   digits=1)
  d$upper.bound   <- ToScientific(d$upper.bound,   digits=1)
  d$start.value   <- ToScientific(d$start.value,   digits=1)
  d$value         <- ToScientific(d$value,         digits=1)
  d$comp.sens     <- ToScientific(d$comp.sens,     digits=1)
  d$rel.comp.sens <- ToScientific(d$rel.comp.sens, digits=1)

  d$start.value[is.start] <- sprintf("$\\mathbf{%s}$", substr(d$start.value, 2, nchar(d$start.value) - 1L)[is.start])
  d$lower.bound[is.lower] <- sprintf("$\\mathbf{%s}$", substr(d$lower.bound, 2, nchar(d$lower.bound) - 1L)[is.lower])
  d$upper.bound[is.upper] <- sprintf("$\\mathbf{%s}$", substr(d$upper.bound, 2, nchar(d$upper.bound) - 1L)[is.upper])
  d$value[is.value]       <- sprintf("$\\mathbf{%s}$", substr(d$value, 2, nchar(d$value) - 1L)[is.value])

  d <- d[, c("desc", "ID", "lower.bound", "upper.bound",
             "start.value", "value", "rel.comp.sens", "rank")]
  columns <- c("Parameter type",
               "Site \\\\ No.",
               "Lower \\\\ bound",
               "Upper \\\\ bound",
               "Starting \\\\ value",
               "Calibrated \\\\ value",
               "Relative \\\\ composite \\\\ sensitivity",
               "Rank")
  colnames(d) <- sprintf("\\textbf{\\shortstack{%s}}", columns)
  cap1 <- "Estimates and composite sensitives of parameters varied during the model calibration process."
  cap2 <- c("\\textbf{Site No.}: is a unique identifier for estimated parameters within a parameter type.",
            "That is the pilot-point identifier (point No.) for horizontal hydraulic conductivity and storage coefficient;",
            "river subreach identifier (subreach No.) for riverbed conductance;",
            "groundwater-outlet boundary (1 is `Stanton Crossing' and 2 is `Silver Creek') for drain conductance;",
            "irrigation-entity identifier (entity No.) for irrigation efficiency; and",
            "tributary-valley identifier (tributary No.) for tributary underflow scalar.",
            "\\textbf{Lower} and \\textbf{Upper bound}: define the range of values a parameter can take during the model calibration process.",
            "\\textbf{Starting value}: is the initial parameter estimate prior to model calibration.",
            "\\textbf{Calibrated value}: estimated by PEST.",
            "Entry in \\textbf{bold} indicates that the calibrated parameter value is at a bound or starting value.",
            "\\textbf{Relative composite sensitivity}: statistic generated during the final iteration of PEST.",
            "\\textbf{Rank}: of the relative composite sensitivity in descending order.",
            "\\textbf{Abbreviations}: m/d, meters per day; m\\textsuperscript{2}/d, square meters per day; d, days; --, no site number")
  tbl <- xtable::xtable(d, label=label)
  if (idxs[1] == 1L)
    xtable::caption(tbl) <- c(sprintf("%s [%s]", cap1, paste(cap2, collapse=" ")), cap1)
  else
    xtable::caption(tbl) <- sprintf("%s---Continued", cap1)
  hline.after <- if (is.last.hline) c(-1, 0, nrow(tbl)) else c(-1, 0)
  print(tbl, include.rownames=FALSE, caption.placement="top", booktabs=TRUE,
        sanitize.colnames.function=function(x){x}, size="\\small", NA.string="--",
        sanitize.text.function=identity, hline.after=hline.after,
        format.args=list(big.mark=","))
}
@

<<table_sen, echo=FALSE, results="asis">>=
n <- nrow(sensitivity)
PrintTable(idxs <- 1:(n <- 46L), FALSE, label <- "table_sen")
@
\captionsetup[table]{list=no}
<<echo=FALSE, results="asis">>=
s <- unique(c(seq(n, nrow(sensitivity), 56L), nrow(sensitivity)))
for (i in head(seq_along(s), -1)) {
  cat("\\addtocounter{table}{-1}\n")
  PrintTable((s[i] + 1L):s[i + 1], s[i + 1L] == tail(s, 1), paste0(label, "_", i))
}
@
\captionsetup[table]{list=yes}
\clearpage

<<echo=FALSE>>=
FUN <- function(d, xlim, ylim, xlab=NULL, col="#666666") {
  height <- d$rel.comp.sens
  ylim <- range(pretty(height))
  op <- par(mar=c(3.5, 4.1, 0.5, 0.5), lwd=0.5)
  barplot(height, width=1, space=0, names=d$ID, xlim=xlim, ylim=ylim,
          axes=FALSE, lwd=0.5, border=NA, col=col, xaxt="n", ann=FALSE)
  xat <- seq_len(length(height) + 1)
  abline(v=xat - 1, lwd=0.5, col="white")
  tcl <- -7.2 / par("cra")[2]
  if (!is.null(xlab))
    axis(1, at=head(xat, -1) - 0.5, labels=d$ID, tcl=tcl, cex.axis=0.7,
         lwd=0.5, mgp=c(2.5, 0.4, 0.2))
  yat <- pretty(height)
  axis(2, at=yat, labels=format(yat, big.mark=","), cex.axis=0.7, tcl=-tcl,
       lwd=0.5, las=1, mgp=c(1.4, 0.4, 0))
  title(ylab ="Relative composite sensitivity", cex.lab=0.7, line=2)
  mtext(xlab, side=1, line=1.6, at=length(height) / 2, cex=0.7)
}
@

\begin{figure}
  \begin{subfigure}{\textwidth}
    \caption{Horizontal hydraulic conductivity \label{fig:graph_sen_a}}
    <<graph_sen_a, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2]>>=
    desc <- "Horizontal hydraulic conductivity"
    d <- sensitivity[sensitivity$parameter.desc %in% desc, ]
    xlim <- c(1L, sum(sensitivity$parameter.desc == desc))
    xlab <- "Pilot-point identifier (point No.)"
    cols <- c("#CE542E", "#4D26D7", "#E5CB1A")
    col <- cols[as.integer(factor(d$group))]
    FUN(d[order(d$ID), ], xlim, ylim, xlab, col=col)
    leg <- paste("Model layer", 1:3)
    legend("topleft", leg, fill=cols, border=cols, inset=0.05, cex=0.7,
           pt.cex=1, box.lwd=NA, xpd=NA, bg="#FFFFFFE7")
    @
  \end{subfigure}

  \vspace{0.5cm}%

  \begin{subfigure}{\textwidth}
    \caption{Storage coefficient \label{fig:graph_sen_b}}
    <<graph_sen_b, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2]>>=
    desc <- "Storage coefficient"
    d <- sensitivity[sensitivity$parameter.desc %in% desc, ]
    FUN(d[order(d$ID), ], xlim, ylim, xlab, col=col)
    leg <- paste("Model layer", 1:3)
    legend("topleft", leg, fill=cols, border=cols, inset=0.05, cex=0.7,
           pt.cex=1, box.lwd=NA, xpd=NA, bg="#FFFFFFE7")
    @
  \end{subfigure}
  \caption{Composite sensitivities of adjusted parameters generated by PEST. Parameters include
    (\textit{\textbf{A}}) hydraulic conductivity, (\textit{\textbf{B}}) storage coefficient,
    (\textit{\textbf{C}}) irrigation efficiency, (\textit{\textbf{D}}) riverbed conductance,
    (\textit{\textbf{E}}) drain conductance, and (\textit{\textbf{F}}) tributary underflow. \label{fig:graph_sen}}
\end{figure}

\captionsetup[figure]{list=no}

\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Irrigation efficiency \label{fig:graph_sen_c}}
    <<graph_sen_c, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2]>>=
    desc <- "Irrigation efficiency"
    d <- data.frame(ID=seq_len(length(levels(irr.entities@data$EntityName))))
    d <- dplyr::left_join(d, sensitivity[sensitivity$parameter.desc %in% desc, ], by="ID")
    xlab <- "Irrigation-entity identifier (entity No.)"
    FUN(d[order(d$ID), ], xlim, ylim, xlab)
    @
  \end{subfigure}

  \vspace{0.5cm}%

  \begin{subfigure}{\textwidth}
    \caption{Riverbed conductance \label{fig:graph_sen_d}}
    <<graph_sen_d, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2]>>=
    desc <- "Riverbed conductance"
    d <- sensitivity[sensitivity$parameter.desc %in% desc, ]
    xlab <- "River subreach identifier (subreach No.)"
    FUN(d[order(d$ID), ], xlim, ylim, xlab)
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}

\begin{figure}
  \ContinuedFloat
  \begin{subfigure}{\textwidth}
    \caption{Drain conductance \label{fig:graph_sen_e}}
    <<graph_sen_e, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2]>>=
    desc <- "Drain conductance"
    d <- sensitivity[sensitivity$parameter.desc %in% desc, ]
    col <- c("#CE542E", "#4D26D7", "#E5CB1A", "#02779E")
    FUN(d[order(d$ID), ], xlim, ylim, col=col)
    leg <- c("Stanton Crossing", paste("Silver Creek, model layer", 1:3))
    legend("topleft", leg, fill=col, border=col, inset=0.1, cex=0.7,
           pt.cex=1, box.lwd=NA, xpd=NA, bg="#FFFFFFE7")
    @
  \end{subfigure}

  \vspace{0.5cm}%

  \begin{subfigure}{\textwidth}
  \caption{Tributary underflow scalar \label{fig:graph_sen_f}}
  <<graph_sen_f, echo=FALSE, fig.width=fin.graph.short[1], fig.height=fin.graph.short[2]>>=
    desc <- "Tributary underflow scalar"
    d <- sensitivity[sensitivity$parameter.desc %in% desc, ]
    xlab <- "Tributary-valley identifier (tributary No.)"
    col <- "#A8C0A8"
    FUN(d[order(d$ID), ], xlim, ylim, xlab, col=col)
    @
  \end{subfigure}
  \caption{---Continued}
\end{figure}

\captionsetup[figure]{list=yes}

% =========================================================================

<<echo=FALSE, message=FALSE>>=
ExportRasterStack(rs, "ancillary/calibrated/model")
@

% =========================================================================

% \vfill\centerline{Created on \Sexpr{format(Sys.time(), "%B %e, %Y")}; total processing time was \Sexpr{format(difftime(Sys.time(), t0), digits=3)}.}

\end{document}
